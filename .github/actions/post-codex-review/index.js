const core = require('@actions/core');
const github = require('@actions/github');
const fs = require('fs');
const path = require('path');

/**
 * Format suggestion as GitHub PR review comment
 */
function formatSuggestion(suggestion) {
  const severity = {
    'error': '🔴',
    'warning': '⚠️',
    'info': '💡'
  };

  const icon = severity[suggestion.severity] || '💡';

  return `${icon} **${suggestion.type.charAt(0).toUpperCase() + suggestion.type.slice(1)} Suggestion**

**Issue**: ${suggestion.message}

${suggestion.original_code ? `
### Current Code:
\`\`\`${suggestion.language || 'javascript'}
${suggestion.original_code}
\`\`\`
` : ''}

${suggestion.suggested_code ? `
### Suggested Code:
\`\`\`suggestion
${suggestion.suggested_code}
\`\`\`
` : ''}

${suggestion.explanation ? `
### Explanation:
${suggestion.explanation}
` : ''}

**Confidence**: ${(suggestion.confidence * 100).toFixed(0)}%
**Impact**: Risk: ${suggestion.impact?.risk || 'low'} | Performance: ${suggestion.impact?.performance || 'neutral'}

---
*Generated by Codex AI Analysis*`;
}

/**
 * Create review comments from suggestions
 */
async function createReviewComments(octokit, owner, repo, prNumber, suggestions) {
  const comments = [];

  for (const suggestion of suggestions) {
    if (suggestion.file && suggestion.line) {
      comments.push({
        path: suggestion.file,
        line: suggestion.line_end || suggestion.line,
        side: 'RIGHT',
        body: formatSuggestion(suggestion)
      });
    }
  }

  if (comments.length > 0) {
    try {
      // Get the latest commit SHA
      const { data: pr } = await octokit.rest.pulls.get({
        owner,
        repo,
        pull_number: prNumber
      });

      // Create a review with comments
      await octokit.rest.pulls.createReview({
        owner,
        repo,
        pull_number: prNumber,
        commit_id: pr.head.sha,
        event: 'COMMENT',
        comments: comments
      });

      core.info(`Posted ${comments.length} review comments`);
    } catch (error) {
      core.warning(`Failed to post review comments: ${error.message}`);
      // Fall back to issue comments
      await postAsIssueComment(octokit, owner, repo, prNumber, suggestions);
    }
  }
}

/**
 * Post suggestions as issue comment (fallback)
 */
async function postAsIssueComment(octokit, owner, repo, prNumber, suggestions) {
  const summary = formatAnalysisSummary(suggestions);

  await octokit.rest.issues.createComment({
    owner,
    repo,
    issue_number: prNumber,
    body: summary
  });

  core.info('Posted analysis as issue comment');
}

/**
 * Format analysis summary
 */
function formatAnalysisSummary(suggestions) {
  const groupedBySeverity = suggestions.reduce((acc, s) => {
    acc[s.severity] = (acc[s.severity] || 0) + 1;
    return acc;
  }, {});

  return `## 🤖 Codex Analysis Results

### 📊 Summary
- **Total Suggestions**: ${suggestions.length}
- **Errors**: ${groupedBySeverity.error || 0}
- **Warnings**: ${groupedBySeverity.warning || 0}
- **Info**: ${groupedBySeverity.info || 0}

### 💡 Top Suggestions

${suggestions.slice(0, 5).map((s, i) => `
${i + 1}. **${s.message}**
   - File: \`${s.file || 'N/A'}\`
   - Line: ${s.line || 'N/A'}
   - Severity: ${s.severity}
   - Confidence: ${(s.confidence * 100).toFixed(0)}%
`).join('\n')}

${suggestions.length > 5 ? `\n*And ${suggestions.length - 5} more suggestions...*` : ''}

---
*This analysis was performed by Codex AI. Review suggestions carefully before applying.*
*[View detailed analysis](https://github.com/${github.context.repo.owner}/${github.context.repo.repo}/pull/${prNumber}/files)*`;
}

/**
 * Main execution
 */
async function run() {
  try {
    // Get inputs
    const analysisFile = core.getInput('analysis-file', { required: true });
    const prNumber = parseInt(core.getInput('pr-number', { required: true }));
    const token = core.getInput('github-token', { required: true });

    // Initialize Octokit
    const octokit = github.getOctokit(token);
    const { owner, repo } = github.context.repo;

    // Read analysis file
    const analysisPath = path.resolve(analysisFile);
    if (!fs.existsSync(analysisPath)) {
      throw new Error(`Analysis file not found: ${analysisPath}`);
    }

    const analysis = JSON.parse(fs.readFileSync(analysisPath, 'utf8'));
    core.info(`Loaded analysis with ${analysis.suggestions?.length || 0} suggestions`);

    // Post review comments
    if (analysis.suggestions && analysis.suggestions.length > 0) {
      await createReviewComments(octokit, owner, repo, prNumber, analysis.suggestions);

      // Add labels
      const labels = ['codex-reviewed'];
      if (analysis.suggestions.some(s => s.severity === 'error')) {
        labels.push('needs-attention');
      }

      await octokit.rest.issues.addLabels({
        owner,
        repo,
        issue_number: prNumber,
        labels
      });

      core.info(`Added labels: ${labels.join(', ')}`);
    } else {
      // No suggestions - post success comment
      await octokit.rest.issues.createComment({
        owner,
        repo,
        issue_number: prNumber,
        body: '## ✅ Codex Analysis Complete\n\nNo issues or suggestions found. The code looks great!'
      });

      await octokit.rest.issues.addLabels({
        owner,
        repo,
        issue_number: prNumber,
        labels: ['codex-approved']
      });
    }

    core.setOutput('suggestions-count', analysis.suggestions?.length || 0);
    core.setOutput('review-posted', 'true');

  } catch (error) {
    core.setFailed(`Action failed: ${error.message}`);
  }
}

// Run the action
run();